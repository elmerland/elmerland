<a name="Null-Pointer-Constant"></a>
<div class="header">
<p>
Next: <a href="Important-Data-Types.html#Important-Data-Types" accesskey="n" rel="next">Important Data Types</a>, Previous: <a href="Variadic-Functions.html#Variadic-Functions" accesskey="p" rel="prev">Variadic Functions</a>, Up: <a href="Language-Features.html#Language-Features" accesskey="u" rel="up">Language Features</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Null-Pointer-Constant-1"></a>
<h3 class="section">A.3 Null Pointer Constant</h3>
<a name="index-null-pointer-constant"></a>

<p>The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type <code>void
*</code>.  The preferred way to write a null pointer constant is with
<code>NULL</code>.
</p>
<dl>
<dt><a name="index-NULL"></a>Macro: <em>void *</em> <strong>NULL</strong></dt>
<dd><p>This is a null pointer constant.
</p></dd></dl>

<p>You can also use <code>0</code> or <code>(void *)0</code> as a null pointer
constant, but using <code>NULL</code> is cleaner because it makes the purpose
of the constant more evident.
</p>
<p>If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won&rsquo;t know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.
</p>



