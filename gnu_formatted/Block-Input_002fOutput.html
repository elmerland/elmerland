<a name="Block-Input_002fOutput"></a>
<div class="header">
<p>
Next: <a href="Formatted-Output.html#Formatted-Output" accesskey="n" rel="next">Formatted Output</a>, Previous: <a href="Unreading.html#Unreading" accesskey="p" rel="prev">Unreading</a>, Up: <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" accesskey="u" rel="up">I/O on Streams</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Block-Input_002fOutput-1"></a>
<h3 class="section">12.11 Block Input/Output</h3>

<p>This section describes how to do input and output operations on blocks
of data.  You can use these functions to read and write binary data, as
well as to read and write text in fixed-size blocks instead of by
characters or lines.
<a name="index-binary-I_002fO-to-a-stream"></a>
<a name="index-block-I_002fO-to-a-stream"></a>
<a name="index-reading-from-a-stream_002c-by-blocks"></a>
<a name="index-writing-to-a-stream_002c-by-blocks"></a>
</p>
<p>Binary files are typically used to read and write blocks of data in the
same format as is used to represent the data in a running program.  In
other words, arbitrary blocks of memory&mdash;not just character or string
objects&mdash;can be written to a binary file, and meaningfully read in
again by the same program.
</p>
<p>Storing data in binary form is often considerably more efficient than
using the formatted I/O functions.  Also, for floating-point numbers,
the binary form avoids possible loss of precision in the conversion
process.  On the other hand, binary files can&rsquo;t be examined or modified
easily using many standard file utilities (such as text editors), and
are not portable between different implementations of the language, or
different kinds of computers.
</p>
<p>These functions are declared in <samp>stdio.h</samp>.
<a name="index-stdio_002eh-5"></a>
</p>
<dl>
<dt><a name="index-fread"></a>Function: <em>size_t</em> <strong>fread</strong> <em>(void *<var>data</var>, size_t <var>size</var>, size_t <var>count</var>, FILE *<var>stream</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe 
| AS-Unsafe corrupt
| AC-Unsafe lock corrupt
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>This function reads up to <var>count</var> objects of size <var>size</var> into
the array <var>data</var>, from the stream <var>stream</var>.  It returns the
number of objects actually read, which might be less than <var>count</var> if
a read error occurs or the end of the file is reached.  This function
returns a value of zero (and doesn&rsquo;t read anything) if either <var>size</var>
or <var>count</var> is zero.
</p>
<p>If <code>fread</code> encounters end of file in the middle of an object, it
returns the number of complete objects read, and discards the partial
object.  Therefore, the stream remains at the actual end of the file.
</p></dd></dl>

<dl>
<dt><a name="index-fread_005funlocked"></a>Function: <em>size_t</em> <strong>fread_unlocked</strong> <em>(void *<var>data</var>, size_t <var>size</var>, size_t <var>count</var>, FILE *<var>stream</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe race:stream
| AS-Unsafe corrupt
| AC-Unsafe corrupt
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>The <code>fread_unlocked</code> function is equivalent to the <code>fread</code>
function except that it does not implicitly lock the stream.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<dl>
<dt><a name="index-fwrite"></a>Function: <em>size_t</em> <strong>fwrite</strong> <em>(const void *<var>data</var>, size_t <var>size</var>, size_t <var>count</var>, FILE *<var>stream</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe 
| AS-Unsafe corrupt
| AC-Unsafe lock corrupt
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>This function writes up to <var>count</var> objects of size <var>size</var> from
the array <var>data</var>, to the stream <var>stream</var>.  The return value is
normally <var>count</var>, if the call succeeds.  Any other value indicates
some sort of error, such as running out of space.
</p></dd></dl>

<dl>
<dt><a name="index-fwrite_005funlocked"></a>Function: <em>size_t</em> <strong>fwrite_unlocked</strong> <em>(const void *<var>data</var>, size_t <var>size</var>, size_t <var>count</var>, FILE *<var>stream</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe race:stream
| AS-Unsafe corrupt
| AC-Unsafe corrupt
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>The <code>fwrite_unlocked</code> function is equivalent to the <code>fwrite</code>
function except that it does not implicitly lock the stream.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Formatted-Output.html#Formatted-Output" accesskey="n" rel="next">Formatted Output</a>, Previous: <a href="Unreading.html#Unreading" accesskey="p" rel="prev">Unreading</a>, Up: <a href="I_002fO-on-Streams.html#I_002fO-on-Streams" accesskey="u" rel="up">I/O on Streams</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



