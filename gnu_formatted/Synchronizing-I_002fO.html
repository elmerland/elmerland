<a name="Synchronizing-I_002fO"></a>
<div class="header">
<p>
Next: <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" accesskey="n" rel="next">Asynchronous I/O</a>, Previous: <a href="Waiting-for-I_002fO.html#Waiting-for-I_002fO" accesskey="p" rel="prev">Waiting for I/O</a>, Up: <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level I/O</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Synchronizing-I_002fO-operations"></a>
<h3 class="section">13.9 Synchronizing I/O operations</h3>

<a name="index-synchronizing"></a>
<p>In most modern operating systems, the normal I/O operations are not
executed synchronously.  I.e., even if a <code>write</code> system call
returns, this does not mean the data is actually written to the media,
e.g., the disk.
</p>
<p>In situations where synchronization points are necessary, you can use
special functions which ensure that all operations finish before
they return.
</p>
<dl>
<dt><a name="index-sync"></a>Function: <em>void</em> <strong>sync</strong> <em>(void)</em></dt>
<dd><p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>A call to this function will not return as long as there is data which
has not been written to the device.  All dirty buffers in the kernel will
be written and so an overall consistent system can be achieved (if no
other process in parallel writes data).
</p>
<p>A prototype for <code>sync</code> can be found in <samp>unistd.h</samp>.
</p></dd></dl>

<p>Programs more often want to ensure that data written to a given file is
committed, rather than all data in the system.  For this, <code>sync</code> is overkill.
</p>

<dl>
<dt><a name="index-fsync"></a>Function: <em>int</em> <strong>fsync</strong> <em>(int <var>fildes</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>The <code>fsync</code> function can be used to make sure all data associated with
the open file <var>fildes</var> is written to the device associated with the
descriptor.  The function call does not return unless all actions have
finished.
</p>
<p>A prototype for <code>fsync</code> can be found in <samp>unistd.h</samp>.
</p>
<p>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>fsync</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>fsync</code> should be
protected using cancellation handlers.
</p>
<p>The return value of the function is zero if no error occurred.  Otherwise
it is <em>-1</em> and the global variable <var>errno</var> is set to the
following values:
</p><dl compact="compact">
<dt><code>EBADF</code></dt>
<dd><p>The descriptor <var>fildes</var> is not valid.
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>No synchronization is possible since the system does not implement this.
</p></dd>
</dl>
</dd></dl>

<p>Sometimes it is not even necessary to write all data associated with a
file descriptor.  E.g., in database files which do not change in size it
is enough to write all the file content data to the device.
Meta-information, like the modification time etc., are not that important
and leaving such information uncommitted does not prevent a successful
recovering of the file in case of a problem.
</p>
<dl>
<dt><a name="index-fdatasync"></a>Function: <em>int</em> <strong>fdatasync</strong> <em>(int <var>fildes</var>)</em></dt>
<dd><p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>When a call to the <code>fdatasync</code> function returns, it is ensured
that all of the file data is written to the device.  For all pending I/O
operations, the parts guaranteeing data integrity finished.
</p>
<p>Not all systems implement the <code>fdatasync</code> operation.  On systems
missing this functionality <code>fdatasync</code> is emulated by a call to
<code>fsync</code> since the performed actions are a superset of those
required by <code>fdatasync</code>.
</p>
<p>The prototype for <code>fdatasync</code> is in <samp>unistd.h</samp>.
</p>
<p>The return value of the function is zero if no error occurred.  Otherwise
it is <em>-1</em> and the global variable <var>errno</var> is set to the
following values:
</p><dl compact="compact">
<dt><code>EBADF</code></dt>
<dd><p>The descriptor <var>fildes</var> is not valid.
</p>
</dd>
<dt><code>EINVAL</code></dt>
<dd><p>No synchronization is possible since the system does not implement this.
</p></dd>
</dl>
</dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Asynchronous-I_002fO.html#Asynchronous-I_002fO" accesskey="n" rel="next">Asynchronous I/O</a>, Previous: <a href="Waiting-for-I_002fO.html#Waiting-for-I_002fO" accesskey="p" rel="prev">Waiting for I/O</a>, Up: <a href="Low_002dLevel-I_002fO.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level I/O</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



