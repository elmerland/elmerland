<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>
    
      Thread Synchronization
    
  </title>

  <link rel="stylesheet" type="text/css" href="/css/main.css">

  
  
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="js/jquery.fittext.js"></script>
  <script src="//use.typekit.net/fee4ufc.js"></script>
  <script>try{Typekit.load();}catch(e){}</script>

  
</head>

<!-- <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Thread Synchronization</title>
  <meta name="description" content="An exploration of threads">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/systems/c/threads/synchronization/2014/02/27/thread-synchronization.html">
  <link rel="alternate" type="application/rss+xml" title="Elmer Landaverde" href="http://yourdomain.com/feed.xml" />
</head>
 -->

  <body>

    <header class="site-header">
  <h1 class="site-title">Elmer Landaverde</h1>
  <nav class="site-nav">
    <ul>
      <li><a href="#">About</a></li>
      <li class="nav-middot">·</li>
      <li><a href="#">Blog</a></li>
      <li class="nav-middot">·</li>
      <li><a href="#">Gallery</a></li>
    </ul>
  </nav>
</header>

<!-- <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Elmer Landaverde</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>
 -->


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Thread Synchronization</h1>
    <p class="post-meta">Feb 27, 2014 • Elmer Landaverde • elmer@vt.edu</p>
  </header>

  <article class="post-content">
    <p>The most challenging part of working with threads is spotting and fixing bugs. It is so because the situations and scenarios that have to be considered can seem far-fetched and one in a million. Unfortunately if a thread is running millions of times every few seconds that one in a million scenario will happen often. As it is often the case the best way to master something is to practice it. The aim of this article is to expose the common concerns and sources of bugs that arise from working with threads. This article will develop an implementation for a thread safe pipe. In doing this several unsafe or non-deterministic behaviors will have to be identified and fixed that will serve as practice for debugging threads. I hope this article proves to be a good tool for getting started with threads.</p>
<h1>Problem</h1>
<p>The producer consumer problem is often used to illustrate the challenges of thread synchronization. It also offers an introduction on the issues that need to be considered when dealing with threads. The problem itself is described as follows:</p>
<blockquote>
<p>The problem describes two processes, the producer and the consumer, who share a common, fixed-size buffer used as a queue. The producer&#8217;s job is to generate a piece of data, put it into the buffer and start again. At the same time, the consumer is consuming the data (i.e., removing it from the buffer) one piece at a time. The problem is to make sure that the producer won&#8217;t try to add data into the buffer if it&#8217;s full and that the consumer won&#8217;t try to remove data from an empty buffer.<br />
<a href="http://en.wikipedia.org/wiki/Producer-consumer_problem">Producer-consumer Problem. Wikipedia. Wikimedia Foundation, 06 Oct. 2014. Web. 09 July 2014.</a></p>
</blockquote>
<p>In addition to worrying about threads writing to a full buffer or reading from an empty buffer; the problem of two threads trying to modifying the buffer at the same time must also be considered. There are therefore, two synchronization issues in the producer-consumer problem.</p>
<p>This article will present a solution to the producer-consumer problem by implementing a pipe. Built in pipes in C are able to handle several threads writing to and reading from them. The goal of this article is to recreate this behavior and be able to construct a pipe that can handle multiple producers and multiple consumer threads simultaneously.</p>
<h1>Setters and Getters</h1>
<p>The solution for this problem will be implemented using C. The first step is therefore to create a header file to declare the functions that will need to be implemented. This header file will also include the declaration of a pipe structure that will store information related to the buffer, pipe status, and all the necessary locks and conditional variables.</p>
<p>code/code_1.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &quot;bounded-buf.h&quot;</span>
<span class="k">struct</span> <span class="n">int_pipe</span> <span class="p">{</span>
  <span class="kt">bounded_buffer_t</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">int_pipe</span> <span class="kt">int_pipe_t</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">int_pipe_emtpy</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">int_pipe_full</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">int_pipe_closed</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">int_pipe_init</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">int</span>  <span class="nf">int_pipe_size</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">int</span>  <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">int</span>  <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">int_pipe_close</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">);</span></code></pre></div></p>
<p>The only two functions that pose real difficulties are the write and read functions. The implementation for these will be filled in later in the article. Meanwhile, the simpler functions have being already filled out below to offer some context for how everything is initialized and closed.</p>
<p>code/code_2.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>
<span class="cp">#include &quot;int-pipe.h&quot;</span>
<span class="kt">bool</span> <span class="nf">int_pipe_empty</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bounded_buffer_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">int_pipe_full</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bounded_buffer_full</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">int_pipe_init</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bounded_buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_size</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bounded_buffer_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">int_pipe_close</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">int_pipe_closed</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre></div></p>
<p>With the basic functionality out of the way lets start implementing the `int_pipe_write` and `int_pipe_read` functions.</p>
<h1>Locks</h1>
<p>A naïve programmer might come up with the following solution to the implementation of the `int_pipe_write` and `int_pipe_read` functions:</p>
<p>code/code_3.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<p>The above implementation first goes into a `while` loop that checks if the buffer is empty/full and if the pipe is closed, when the conditions are satisfied the loop will exit. Upon exiting the status of the pipe is checked again. This is necessary because otherwise it would not be possible to determine if the `while` loop exited due to the pipe closing or because the buffer was not empty/full. Next a sanity check is performed again on the buffer and pipe status. Finally reading or writing to the pipe and returning the appropriate result.</p>
<p>Consider now the possibility of two threads trying to read/write from the buffer concurrently. If this where to happen, the program would behave in a non-deterministic fashion. Take for example the following scenario where two threads are trying to read from the end of the buffer and then removing the last element:</p>
<table>
<thead>
<tr>
      <th>Thread 1</th>
      <th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
      <td>Get pointer to end of buffer</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>Read the integer at pointer</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Get pointer to end of buffer (Same as thread 1)</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Read the integer at pointer (Same as thread 1)</td>
</tr>
<tr>
      <td>Remove last element in buffer</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Remove last element in buffer</td>
</tr>
</tbody>
</table>
<p>This will result in the two threads reading the same value from the buffer and removing two elements from the end of the buffer. This area is then considered a <b>critical section</b>. The best way to prevent two or more threads from accessing a critical section is to use a lock. An inspection of the header file will reveal that tThis will result in the two threads reading the same value from the buffer and removing two elements from the end of the buffer. This area is then considered a <b>critical section</b>. The best way to prevent two or more threads from accessing a critical section is to use a lock. To accomplish this a lock variable needs to be added to the `int_pipe` structure as illustrated bellow:</p>
<p>code/code_4.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">int_pipe</span> <span class="p">{</span>
  <span class="kt">bounded_buffer_t</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
  <span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span></code></pre></div></p>
<p>Lets use this `mutex` lock to make sure that no threads are concurrently accessing the buffer at the same time by adding the following lines to the read and write functions:</p>
<p>code/code_5.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<p>This solves the problem of concurrent threads trying to modify the buffer. If we were to run the pipe as it is it would still behave non-deterministically. Consider the following scenario where two threads call the `int_pipe_read` function at the same time and there is only one element remaining in the buffer:</p>
<table>
<thead>
<tr>
      <th>Thread 1</th>
      <th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
      <td>Enter while loop</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>Exit while loop: Buffer has one element</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>Check if pipe is closed</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Enter while loop</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Exit while loop: Buffer has one element</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Check if pipe is closed</td>
</tr>
<tr>
      <td>Get lock on `mutex`</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>Remove last element of buffer</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>Release lock on `mutex` (Buffer is empty now)</td>
      <td>[blocked]</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Get lock on `mutex`</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Remove last element of buffer</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td><span class="caps">ERROR</span>: tried to remove element from empty list    </tr>
</tbody>
</table>
<p>If this where to happen the first thread would remove the only element in the buffer list. Then, since the second thread has already exited from the `while` loop it would also attempt to remove the last element of the buffer which will cause an error (or segmentation fault depending on how the buffer is implemented). Again a naïve programmer might suggest to move the `mutex` lock before the `while` loop. The problem with this is that if the lock is placed before the `while` loop then no other thread will be able to access the buffer. Therefore if one thread executes and it goes inside of the `while` loop because the buffer is empty, the thread will never exit out of the `while` loop. This is because the first thread has a lock on the `mutex` and therefore no other threads will be able to write or read from the buffer, causing the first thread to loop infinitely.</p>
<p>To solve this problem another lock will need to be added to the `int_pipe` structure and the `while` loop inside of the `int_pipe_read` function will need to be modified. Lets first look at the solution before explaining why this solution works. First the new lock needs to be added to the structure declaration:</p>
<p>code/code_6.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">int_pipe</span> <span class="p">{</span>
  <span class="kt">bounded_buffer_t</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
  <span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="kt">pthread_mutex_t</span> <span class="n">avail_data</span><span class="p">;</span>
<span class="p">};</span></code></pre></div></p>
<p>Next, lets use the newly created `avail_data` and the `mutex` locks to get the desired behavior from the pipe program:</p>
<p>code/code_7.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">int_pipe_init</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bounded_buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<p>This might seem confusing to many and you would be right to be confused (I know I certainly was). Lets first run through all the changes that were made. First a new lock is initialized in the `int_pipe_init` function and it is then locked. Next an unlock statement inside of the `int_pipe_write` was added for the `avail_data` lock. Inside of the `int_pipe_read` function several changes where made. First the `mutex` lock was moved to top of the function before the `while` loop. Inside the `while` loop three statements were added. The first statement unlocks the `mutex` lock, the second tries to get a lock on the `avail_date` lock, and finally the third statement tries to get a lock on the `mutex` lock again.</p>
<p>To understand how the locks and unlocks interact with each other lets run through a quick scenario where one thread is trying to read to the buffer and the other is trying to write to it. Lets also assume that the buffer is empty and the `avail_data` lock is locked when the two threads start executing:</p>
<table>
<thead>
<tr>
      <th>Thread 1</th>
      <th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
      <td>int_pipe_read` function</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Get lock on `mutex`</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Enter while loop: Buffer is empty</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Unlock `mutex`</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Get lock on `avail_data` (Wait)</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Call `int_pipe_write` function&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>While loop: Buffer is empty&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Exit while loop&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Get lock on `mutex`&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Add integer to buffer&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Unlock `avail_data`&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Unlock `mutex`&quot;</td>
</tr>
<tr>
      <td>[blocked]</td>
      <td>Return and exit&quot;</td>
</tr>
<tr>
      <td>Lock on `avail_data` is gained</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Regain lock on `mutex`</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Get and remove last element in buffer</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Unlock `mutex`</td>
      <td>[blocked]&quot;</td>
</tr>
<tr>
      <td>Return and exit</td>
      <td>[blocked]&quot;</td>
</tr>
</tbody>
</table>
<p>Notice how when thread one starts executing the buffer is empty. Because of this the `int_pipe_read` function is going to go into the `while` loop. When this happens the `mutex` lock is realeased, this enables other threads to modify the buffer while thread one is waiting. Next thread one tries to acquire a lock on `avail_data`. When the pipe was initialized the `avail_data` lock is locked, this means that thread one will have to wait until someone unlocks it. At this point thread two kicks in. Because `mutex` was unlocked by thread one it is able to acquire a lock and consequently add a new integer to the buffer. After thread two has written to the buffer it unlocks the `avail_data` lock. This will allow thread one to get the lock once it resumes. Another important thing to notice is that the `avail_data` lock is never released inside of `int_pipe_read` function. This means that the next time a thread find the buffer to be empty it will have to wait until another thread writes to the buffer and unlocks the `avail_data` lock.</p>
<h1>Conditionals</h1>
<p>The code shown in the previous section will work just fine for our purposes. However we can improve on it using a feature of C called <b>conditional variables</b>. These conditionals variables will serve to the replace the three statements inside of the `while` loop in the `int_pipe_read` function with one statement. The reason for doing this is to simplify the code and make it a little easier to understand. Below the modifications to the code are shown. First the header file has to be modified to change the variable type for the `avail_data` lock:</p>
<p>code/code_8.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">int_pipe</span> <span class="p">{</span>
  <span class="kt">bounded_buffer_t</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
  <span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="kt">pthread_cond_t</span>  <span class="n">avail_data</span><span class="p">;</span>
<span class="p">};</span></code></pre></div></p>
<p>Here we show how the main C file will change as a consequence of introducing the <b>conditional variable</b>:</p>
<p>code/code_9.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">int_pipe_init</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bounded_buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Busy wait... */</span><span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<p>A fair question to ask at this point is “Do we still need the `while` loop? Why not make it an `if` statement?” The answer to this is yes we still need the `while` loop. Why? Because threads a tricky. If there is more than one thread reading from the buffer it is entirely possible that right after the wait function receives a signal that something was written to the buffer but before it is able to regain a lock on the `mutex` another thread will start executing. When this thread tries to read from the buffer it will find that the `mutex` is unlock and the buffer is not empty, so it will proceed to read and pop the only element in the buffer. Therefore when the original thread resumes the buffer will now be empty. By leaving the `while` loop in place the thread is guaranteed not to try to read from the buffer without first having a lock on the `mutex` and checking that the buffer is not empty.</p>
<p>At this point the pipe will work as intended for one or more readers and only one writer. What if we want to expand the pipe to handle multiple writers as well as readers? Then we must duplicate the reader functionality to the writer side. This is best done by creating a new <b>conditional variable</b> that we will name `avail_space`. This conditional variable will act as the opposite of the `avail_data` conditional, and will notify the write function that another thread removed an element from the buffer and there is space available to write to the it. Below are the changes that are needed for the expanded functionality. First in the header file:</p>
<p>code/code_10.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">int_pipe</span> <span class="p">{</span>
  <span class="kt">bounded_buffer_t</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
  <span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="kt">pthread_cond_t</span>  <span class="n">avail_data</span><span class="p">;</span>
  <span class="kt">pthread_cond_t</span>  <span class="n">avail_space</span><span class="p">;</span>
<span class="p">};</span></code></pre></div></p>
<p>And next in the main C file:</p>
<p>code/code_11.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">int_pipe_init</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bounded_buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">,</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<h1>Final Result</h1>
<p>The pipe program can now successfully execute as many writer and reader threads as desired and there will be no deadlocks or non-deterministic behavior. However there are a few things missing that have to be considered because the pipe will eventually be closed. When the pipe is closed the thread that is currently being executed will simply return. This creates a problem if there are other threads waiting for the current thread to signal changes to either of the <b>conditional variables</b>. Furthermore if the current thread just ends the `mutex` lock will never be released and so any other threads waiting on the lock might be left hanging. Because of these reasons we have to add the following statements to the code:</p>
<p>code/code_12.c<br />
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">int_pipe_close</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">intp</span><span class="o">-&gt;</span><span class="n">closed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">);</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_write</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">,</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_full</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="n">bounded_buffer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">int_pipe_read</span><span class="p">(</span><span class="kt">int_pipe_t</span> <span class="o">*</span><span class="n">intp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">int_pipe_empty</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">int_pipe_closed</span><span class="p">(</span><span class="n">intp</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bounded_buffer_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">avail_space</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>
<p>To facilitate the perusal of the code above a copies of the complete code is located at here for the <a href="/assets/code/thread-synchronization/pipe.h">header file</a> and here for the <a href="/assets/code/thread-synchronization/pipe.c">main C file</a>. It has more comments and better formatting that could not be include in this article because of space concerns.</p>
<h1>Notes</h1>
<p>This article is by no ways meant to be a complete or comprehensive coverage of threads. It is instead meant to give a starting point in understanding the new issues that have to be considered when working with threads. Because of the complex nature of threads and the length of this article, mistakes are bound to happen. Please let me know of any mistakes in the comments below and I will endeavor to correct and enhance this article so that it provides a great tool for people interested in getting started with threads.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

</footer>

<!-- <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Elmer Landaverde</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Elmer Landaverde</li>
          <li><a href="mailto:elmerlandaverde@domain.com">elmerlandaverde@domain.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/elmerland">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">elmerland</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/elmerlandaverde">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">elmerlandaverde</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</p>
      </div>
    </div>

  </div>

</footer>
 -->

  </body>

</html>
